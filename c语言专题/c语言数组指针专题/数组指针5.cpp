/*
数组指针：首先它是一个指针，它指向一个数组。在32 位系统下永远是占4 个字节，至于它指向的数组占多少字节，不知道。
（当初这句话放在开头，自己没注意，也不想注意，谁会关心它几个字节呢？没想到最终还是它解决了自己的疑问，而且是个key） 
*/

#include<stdio.h>
int main()
{
	int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
	
	int (*p)[4];       
	
	int i,j;
	
	p = a;            	/*你说你不理解为什么是a而不是&a，那我就来仔细说说 
	先从 一维数组 讲起：	int a[10] = {0,1,2,3,4,5,6,7,8,9};
							int *p;
							p = &a;
							printf("%d\n",*p);  (1)
							printf("%d\n",*p+1);  (2)								
				!!难点：(1)式中*p到底代表什么？ (2)式呢？
						解释：1.p代表一整个数组a的地址（这个在数组指针1中已经说的非常清楚了）
							那么我们知道*代表取值，由此，*p不就代表把 整个数组 取出来吗？ 
							这样想真的情有可原，引用的时候就是把a看作一个整体的，怎么解引用的时候开始翻脸不认人人了呢 ？ 
							2.但事实如此，解引用后还是代表首元素的地址（背！！） 
 				！！IM！！！3.重头戏来了，如果每次都这样理解不是要裂开？所以请你以后这样理解：
								*p = *&a = a    a是什么？不就是首元素地址吗！！ 
				给这方法取个名字：  抵消法			巨快！！！
				
	再来讲讲  二维数组：	以此题为例 
							1.在一维数组中 a代表首元素的地址，记住这一条，二维数组一样的
							2.在二维数组中。我一直在理解a[0]代表一个一维数组，里面存放了4个元素
							但是！但是！
							你何尝不能把 a 也看作一个一维数组呢！！（真的离谱，就感觉把黑的说成白的，但是你又不能说它错）    
							有个大牛说过：在C语言中只有一维数组（N维数组的元素是数组），数组名作为指针时永远指向第一个元素 （和自己想的居然一样！） 
							也就是说： a 这个'一维数组' 存放了 3个'元素'，即a[0],a[1],a[2]	
							我问你：a 代表什么？ 显然a代表首元素的地址，那么在这里a不就代表 a[0]的地址嘛！也就是说 a = &a[0]
							3.现在我用高级且更正确的表述来讲一讲：
							一维数组中：a 这个一维数组存放了10个元素 
										a 自然而然代表第一个元素的地址   即 a = &a[0] 
							二维数组中：a 这个二维数组存放了3个一维数组(a[0],a[1],a[2])	，而每个一维数组又存放了4个元素	 
										a 在这里也代表第一个'元素'地址，只不过这第一个'元素'是a[0]，是一个一维数组  即 a = &a[0] 	
*/	
/*
	接下来好好讲讲以下问题：
	a       		 a = &a[0]
	*a       		*a = *&a[0] = a[0]
	a+1      		a+1 = &a[0]+1 = &a[1]    地址+1移向下一个单位，这里一个数组一个单位，所以移动了一个数组的长度（不懂就看数组指针1） 
	*(a+1)       	*(a+1) = *&a[1] = a[1]
	*(a+1)+1     	*(a+1)+1 = a[1]+1 = &a[1][0]+1 = &a[1][1]      这里key是：a[1] = &a[1][0]  这个很容易理解呀，因为已经到了一维数组的领域。
	 																也就是这里是最难的，你总是以为*(a+1)代表一整行，事实上不是，在这里我又要唠叨两句了
																	 a+1确实是等于&a[1]，这里确实是一整个数组的地址，但是*(a+1)取值取不了一整个数组啊
																	  所以最终a[1] =  &a[1][0]，只保留了第一个元素的地址 
	*(*(a+1)+1) 	*(*(a+1)+1) = *&a[1][1] = a[1][1] 
*/
			
	for(i = 0;i < 3;i++)
	{
		for(j = 0;j < 4;j++)
		{
			printf("%2d",*(*(p+i)+j));       //p+i什么意思？一整个数组地址加一，不就是下一个数组的地址？！（具体解释见数组指针1） 
		}
		printf("\n");
	}
	return 0;
}


//这就是             逻辑     

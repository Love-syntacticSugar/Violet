//指向 函数指针数组的指针 

#include<stdio.h>
int main()
{
	int (*p[4])(int,int);           //函数指针数组 
		
//	int (*pp)[4] = &pfarr;         //为什么错？因为你只保证了pp指向的是一个数组，但你不能保证它里面的元素是 函数指针。不仅仅要保证外表相同，还要保证实质相同 
	int (*(*pp)[4])(int,int) = &p; //为什么对？因为不仅保证了pp指向的是一个数组，还保证了它里面的元素是 函数指针。
	
	return 0;
}

/* 对于int (*(*pp)[4])(int,int) = &p;怎么思考？
	毫无疑问先把它拆成int (*     (*pp)[4]     )(int,int) ; 
	1.先说说自己的错误思路：之前自己一直在想 (*pp)[4]是一个指针，然后这个指针怎么怎么样
		就比如自己喜欢用的化归思想，把 (*pp)[4]看成p带进去，而 int (*p)(int,int)中p是一个指向函数的指针 
		这下就乱了，因为 (*pp)[4]本身就是一个指针啊，这样的话不就乱了？ 
	2.所以其实方向就错了，这也是比较离谱的地方 ，最难的地方 
		(*pp)[4]是一个指针没错，但它还是一个数组指针啊！这样，我们试图去问，也只能这样去问：这个指针指向的数组的元素是什么类型的？
		没错，就是int (* )(int,int)的类型，也就是函数指针的类型
		所以外面的int (* )(int,int)并不是为数组指针中指针二字服务的，而是为数组二字服务的！	
*/

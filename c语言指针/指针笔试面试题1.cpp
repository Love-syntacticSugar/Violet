#include<stdio.h>
int main()
{
	int a[5] = {1,2,3,4,5};
	
	int* p = (int*)(&a + 1);    
	//&a+1也是一个数组的地址，只不过这个数组是一个空数组(可以这样认为)，现在你要用指针p来存放这个数组地址那当然不行喽，因为p的返回类型是int*，而 &a + 1的返回类型是int(*)[5] 
	//如何转换？ 一种方法就是用数组指针来存放，另一种就是把这个数组地址强制类型转换为整形地址，然后再用整形指针去接收（这里正是用了第二种方法）
								//问题来了，强制类型转换之后是个什么情况？
								//可以这样理解：原先&a+1指向的是数字5后面连续5个整形的内存（也就是一个数组的大小\20个字节），但强制类型转换之后就只能指向数字5之后一个整形的内存了（4个字节） 
								//这样一来，p-1指向的不就是数字5的地址了嘛  
	
	printf("%d\n",*(p - 1));
	
	printf("%d\n",p[-1]);       //与上面的是等价的 
	
	return 0;
}

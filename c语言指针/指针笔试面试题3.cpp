//OW自己做出来的！！ 

//32位系统下，求下列打印结果 

#include<stdio.h>

int main()
{
	int a[4] = {1,2,3,4};
	
	int* p1 = (int*)(&a+1);
	
	int* p2 = (int*)((int)a + 1);   //为什么会报错？因为我是64位系统，地址是8个字节，你让一个8个字节的数字强制类型转换为4个字节类型的数据，它会丢失精度（丢的不是一点）系统不报错才怪    
	
	printf("%x %x\n",p1[-1],*p2);
	
	return 0;	
}

/* 主要讲讲*p2等于多少，p1很easy   （摘记上说得更详细！！！！第八页） 
	1. (int*)((int)a + 1)是什么意思？意思是地址a加一个字节。   一般a+1都是加4个字节，那怎样做到加一个字节呢？就是这样做！ 
	2.要解决上述问题首先要知道1-2-3-4在内存中是怎么储存的，如下：
		01 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00    每两个数字代表一个字节
		01 00 00 00 储存在地址 &a[0]里面，现在&a[0]增加了一个字节（注意是一个不是四个！）
		那所指向的内容不就向后移动了一个字节了嘛，即 00 00 00 02
		由于小端储存，故AS为 0x 02 00 00 00 
*/

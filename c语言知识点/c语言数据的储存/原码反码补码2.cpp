#include<stdio.h>
int main()
{
	char a = -1;
	/*  1. 100000000000000000000000000000001 原码 
		   111111111111111111111111111111110 反码 
		   111111111111111111111111111111111 补码
		2. 11111111                          计算机取8位（1个字节） 
		3.取出 
		4. 111111111111111111111111111111111 由于定义char有符号数字，而首位为1，故提1
		5.观察到打印%d
		6.求出原码 100000000000000000000000000000001
		7.解出对应十进制数：-1 
	*/
	signed char b = -1;
	//同char，都是有符号数 
	unsigned char c = -1;          //问题：无符号数不是大于0吗，为什么还可以定义一个-1的数 
	/*	虽然定义了unsigned，但-1的就是-1，它的原码反码补码就是按照 有符号数处理的 
		1. 100000000000000000000000000000001 原码 
		   111111111111111111111111111111110 反码 
		   111111111111111111111111111111111 补码
		2. 11111111                          计算机取8位（1个字节）
		3.取出 
		4. 000000000000000000000000011111111 由于定义unsigned char无符号数，故补0即可
		5.观察到打印%d
		6.求出原码 000000000000000000000000011111111 原码 （看到首位的0了吗？说明它是有符号数里面的正数，故原码反码补码相同 ）
		由原码解出c = 255 
	*/
	
	//OW来一个 
	char d = 1; 
	/* 1. 0000000000000000000000000000000001 原码反码补码相同
	   2. 00000001 						  计算机取8位（1个字节）
	   3.取出
	   4. 0000000000000000000000000000000001 由于定义char有符号数字，而首位为0，故提0
	   5. 观察到打印%d
	   6.求出原码 0000000000000000000000000000000001 原码 （由于是正数，故原码反码补码相同 ）
	   由原码解出c = 1
	*/
		
	printf("a=%d,b=%d,c=%d，d=%d\n",a,b,c,d);
	return 0;
}
